package test

import (
	"fmt"
	"strings"
	"testing"

	"github.com/tmck-code/go-ansi-convert/src/convert"
)

func TestFlipVertical(t *testing.T) {
	testCases := []struct {
		name     string
		input    []string
		expected []string
	}{
		{
			name: "ASCII lowercase vertical flip",
			input: []string{
				"abcdefghijklmnopqrstuvwxyz",
			},
			expected: []string{
				"ÉqÉ”pÇÉŸÆƒÉ¥á´‰É¾ÊlÉ¯uodbÉ¹sÊ‡nÊŒÊxÊz",
			},
		},
		{
			name: "ASCII uppercase vertical flip",
			input: []string{
				"ABCDEFGHIJKLMNOPQRSTUVWXYZ",
			},
			expected: []string{
				"âˆ€Bâ†ƒDÆâ„²â…HIÅ¿â‹Šâ…‚Wá´OÔ€ÎŒá´šSâŠ¥âˆ©á´§MXâ…„Z",
			},
		},
		{
			// "â–ˆâ–€â–€â–€â–â–„â–â–ˆ"
			// "â–ˆâ–„â–„â–„â–â–„â–â–ˆ"
			name: "Unicode vertical flip",
			input: []string{
				"â–ˆâ–€â–€â–€â–â–„â–â–ˆ",
			},
			expected: []string{
				"â–ˆâ–„â–„â–„â–â–€â–â–ˆ",
			},
		},
		{
			name: "Unicode vertical flip 2",
			input: []string{
				"â–ğŸ­»ğŸ­ºğŸ­¹ğŸ­¸ğŸ­·ğŸ­¶â–”|ğŸ¬ğŸ¬â–—â––â–â–˜ğŸ¯¤â–˜",
			},
			expected: []string{
				"â–”ğŸ­¶ğŸ­·ğŸ­¸ğŸ­¹ğŸ­ºğŸ­»â–|ğŸ¬ğŸ¬€â–â–˜â–—â––ğŸ¯¥â––",
			},
		},
		{
			name: "Unicode multi-line vertical flip",
			input: []string{
				"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Œâ–€â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ",
				"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€ â–€â–€â–â–„ â–â–ˆâ–ˆâ–ˆâ–ˆ",
				"â–ˆâ–ˆâ–ˆâ–ˆâ–Œâ–€â–€â–â–ˆâ–Œâ–„â–Œ â–‘â–“â–“ â–“â–“â–“ â–ˆâ–ˆâ–ˆâ–ˆ",
				"â–ˆâ–ˆâ–Œâ–€â–€â–€â–€â–€â–€â–Œâ–ˆâ–Œ â– â–€â–„â–“â–â–„â–€â–€â–ˆâ–ˆâ–ˆ",
			},
			expected: []string{
				"â–ˆâ–ˆâ–Œâ–„â–„â–„â–„â–„â–„â–Œâ–ˆâ–Œ â– â–„â–€â–“â–â–€â–„â–„â–ˆâ–ˆâ–ˆ",
				"â–ˆâ–ˆâ–ˆâ–ˆâ–Œâ–„â–„â–â–ˆâ–Œâ–€â–Œ â–‘â–“â–“ â–“â–“â–“ â–ˆâ–ˆâ–ˆâ–ˆ",
				"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„ â–„â–„â–â–€ â–â–ˆâ–ˆâ–ˆâ–ˆ",
				"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–Œâ–„â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ",
			},
		},
		{
			name: "Text box vertical flip",
			input: []string{
				"â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”",
				"â”‚  â•”â•â•â•â•— Some Text  â”‚â–’",
				"â”‚  â•šâ•â•¦â•â• in the box â”‚â–’",
				"â•â•â•¤â•â•â•©â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•¡â–’",
				"â”‚ â”œâ”€â”€â”¬â”€â”€â”¤           â”‚â–’",
				"â”‚ â””â”€â”€â”´â”€â”€â”˜           â”‚â–’",
				"â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â–’",
				"â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’",
			},
			expected: []string{
				"â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’",
				"â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â–’",
				"â”‚ â”Œâ”€â”€â”¬â”€â”€â”           â”‚â–’",
				"â”‚ â”œâ”€â”€â”´â”€â”€â”¤           â”‚â–’",
				"â•â•â•§â•â•â•¦â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•¡â–’",
				"â”‚  â•”â•â•©â•â•— á´‰u Ê‡É¥Ç qox â”‚â–’",
				"â”‚  â•šâ•â•â•â• SoÉ¯Ç âŠ¥ÇxÊ‡  â”‚â–’",
				"â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜",
			},
		},
		{
			name: "LDA-FALL art vertical flip",
			input: []string{
				"    â– â–„â–“â–„   â–„â–Œ    â–„   â–„â–„â– â–ˆâ–€â–€â–„â–‘â–‘â–„ â–ˆâ–ˆâ–ˆâ– â–€â–ˆâ–ˆâ–‘ â–ˆâ–“",
				"      â–€â–ˆâ–ˆâ–“â–â–“â–„â–Œ   â–â–‘ â– â–“â–ˆâ–ˆâ– â–„â–„â– â– â–€â–€â–‘â–‘â–„â–„â–ˆâ–ˆâ–ˆâ–‘â–‘  â–ˆâ–€â– ",
				"     â– â–€â–€â–„â–’â–€â–€â–€â–„â–„â–„ â–€â–’â–Œâ–„â–„ â–€â–€ â–„â–€â–‘â–€â–„â– â–„â–„â–ˆâ–ˆâ–€â–‘â–â–Œ   â–Œ",
				"      â–„â–‘â–‘â–€â–Œ   â–„â– â–€â–€â–€â–„â–„â–ˆâ– â–„  â–€â–€â–„â–ˆâ–€â–ˆâ–ˆâ–€â–€â–„â–’â–’â–ˆâ– â–ˆâ–ˆâ–„",
				"                    â–„â–„â–€â–€â–€â–€â–€â–„â–„â–ˆâ–ˆâ–€â–€â– â–â–“â–“â–„â–ˆâ–ˆ â–€â–€â– ",
				"          â–„â–Œâ–„â–     â–€â–€ â–„â–ˆâ–ˆâ–  â–„â–ˆâ–„â–ˆâ–€â–ˆâ–ˆâ–„â–€â–€  â–â–Œâ–€â–„",
				"     â–„â–    â–â–ˆâ–Œâ–„â– â–„â–„    â–€â–“â–€ â–ˆ â–‘â–ˆâ–â–“â–“â–„â–„     â–ˆâ–„â–Œâ–ˆâ–ˆâ–„â–„",
				"    â–’â–“â–€â– â–„ â–„ â–ˆâ–„â–ˆâ–ˆâ–€â–„        â–ˆâ–ˆâ–Œâ–€â–ˆâ–„â–„â–„â–      â–€â–„â–â–€â–“",
				"  â– â–„â–€â–ˆâ–ˆâ–„â–Œâ–“â–„â–Œâ– â–€â–ˆâ–â–ˆâ–Œ â– â–„â–„â–„â–„â–ˆâ–ˆâ–ˆâ–ˆâ–“ â–„â–‘â–         â–â–Œ",
				"    â–„â–€â–„â–ˆâ–„â–ˆâ–ˆâ–„â–‘ â–â–ˆâ–„â–„â–ˆâ–ˆâ–€â–€â–€  â–â–ˆâ–Œâ–‘â–“â–‘â–€â–„â–„      â–„â–ˆâ–Œ",
				"     â–“â–ˆâ–€â–€â–€â–ˆâ–’â–€â–ˆâ–ˆâ–€â–€       â–„â–ˆâ–ˆ â–â–Œâ–€â–ˆâ–€â–€â–€_   â–â–ˆâ–Œ",
				"    â–â–€â–â–Œâ–ˆâ–„â–  â– â–€         â–â–ˆ,â–Œ â–â–€â–ˆâ–„â–„â–„â–€     â– ",
				"    â–¬â– â–€         â–„ â–„    â–â–ˆâ–â–ˆâ–Œâ–â–‘â–‘â–€â– â–€â–“â–“â–“â–„",
				"            â–Œâ–„ â–â–ˆâ–ˆâ–“â–‘â–„  â–ˆâ–Œâ–ˆâ– â–€â–„â–„â– â–€â–    â–€â–€â– ",
				"    â– â–ˆâ–ˆâ–„  â–„â– â–‘â–‘â–ˆâ–€â–ˆâ–€â–€â–ˆâ–Œâ–„â–ˆâ–€ â–â–Œâ–“â–ˆ  â–„â–ˆâ–ˆâ–„",
				"     â–„ â–€â–„â–ˆâ–‘â–â–“â–€â–ˆâ–€â–„â–‘ â–„â–ˆâ–€    â– â–ˆâ–â–Œâ–ˆâ–€â–€",
				"    â– â–„â–„â–ˆâ–“â–€â–„â–„â–„â–ˆâ–€â–„â–„â–ˆâ–„â–‘â–Œâ–‘â–„â–„     â–",
				"    _â–„â–ˆâ–„â– â–ˆâ–€â– â–€â–ˆâ–ˆâ–ˆâ–€â–â–â–“â–ˆ â–€â–“â–‘    â–€â–“",
				"   â– â–€ â–€â–€â–‘  â–â–ˆâ–„â– â–„â–„â–ˆ â–€â–â–Œ         â–Œ",
				"               â–„â–ˆâ–Œâ–„â–Œâ–â–“",
				"          â–„â–„â–„â–ˆâ–€â–€  â–€â–“â–„â–ˆ",
				"        â–„â–€â–€ â– â–€    â–„â–€ â–ˆâ–€â– â–„â– ",
				"       â–€         â–   â–â–„",
				"                       â– ",
			},
			expected: []string{
				"                       â– ",
				"       â–„         â–   â–â–€",
				"        â–€â–„â–„ â– â–„    â–€â–„ â–ˆâ–„â– â–€â– ",
				"          â–€â–€â–€â–ˆâ–„â–„  â–„â–“â–€â–ˆ",
				"               â–€â–ˆâ–Œâ–€â–Œâ–â–“",
				"   â– â–„ â–„â–„â–‘  â–â–ˆâ–€â– â–€â–€â–ˆ â–„â–â–Œ         â–Œ",
				"    â€¾â–€â–ˆâ–€â– â–ˆâ–„â– â–„â–ˆâ–ˆâ–ˆâ–„â–â–â–“â–ˆ â–„â–“â–‘    â–„â–“",
				"    â– â–€â–€â–ˆâ–“â–„â–€â–€â–€â–ˆâ–„â–€â–€â–ˆâ–€â–‘â–Œâ–‘â–€â–€     â–",
				"     â–€ â–„â–€â–ˆâ–‘â–â–“â–„â–ˆâ–„â–€â–‘ â–€â–ˆâ–„    â– â–ˆâ–â–Œâ–ˆâ–„â–„",
				"    â– â–ˆâ–ˆâ–€  â–€â– â–‘â–‘â–ˆâ–„â–ˆâ–„â–„â–ˆâ–Œâ–€â–ˆâ–„ â–â–Œâ–“â–ˆ  â–€â–ˆâ–ˆâ–€",
				"            â–Œâ–€ â–â–ˆâ–ˆâ–“â–‘â–€  â–ˆâ–Œâ–ˆâ– â–„â–€â–€â– â–„â–    â–„â–„â– ",
				"    â–¬â– â–„         â–€ â–€    â–â–ˆâ–â–ˆâ–Œâ–â–‘â–‘â–„â– â–„â–“â–“â–“â–€",
				"    â–â–„â–â–Œâ–ˆâ–€â–  â– â–„         â–â–ˆ'â–Œ â–â–„â–ˆâ–€â–€â–€â–„     â– ",
				"     â–“â–ˆâ–„â–„â–„â–ˆâ–’â–„â–ˆâ–ˆâ–„â–„       â–€â–ˆâ–ˆ â–â–Œâ–„â–ˆâ–„â–„â–„â€¾   â–â–ˆâ–Œ",
				"    â–€â–„â–€â–ˆâ–€â–ˆâ–ˆâ–€â–‘ â–â–ˆâ–€â–€â–ˆâ–ˆâ–„â–„â–„  â–â–ˆâ–Œâ–‘â–“â–‘â–„â–€â–€      â–€â–ˆâ–Œ",
				"  â– â–€â–„â–ˆâ–ˆâ–€â–Œâ–“â–€â–Œâ– â–„â–ˆâ–â–ˆâ–Œ â– â–€â–€â–€â–€â–ˆâ–ˆâ–ˆâ–ˆâ–“ â–€â–‘â–         â–â–Œ",
				"    â–’â–“â–„â– â–€ â–€ â–ˆâ–€â–ˆâ–ˆâ–„â–€        â–ˆâ–ˆâ–Œâ–„â–ˆâ–€â–€â–€â–      â–„â–€â–â–„â–“",
				"     â–€â–    â–â–ˆâ–Œâ–€â– â–€â–€    â–„â–“â–„ â–ˆ â–‘â–ˆâ–â–“â–“â–€â–€     â–ˆâ–€â–Œâ–ˆâ–ˆâ–€â–€",
				"          â–€â–Œâ–€â–     â–„â–„ â–€â–ˆâ–ˆâ–  â–€â–ˆâ–€â–ˆâ–„â–ˆâ–ˆâ–€â–„â–„  â–â–Œâ–„â–€",
				"                    â–€â–€â–„â–„â–„â–„â–„â–€â–€â–ˆâ–ˆâ–„â–„â– â–â–“â–“â–€â–ˆâ–ˆ â–„â–„â– ",
				"      â–€â–‘â–‘â–„â–Œ   â–€â– â–„â–„â–„â–€â–€â–ˆâ– â–€  â–„â–„â–€â–ˆâ–„â–ˆâ–ˆâ–„â–„â–€â–’â–’â–ˆâ– â–ˆâ–ˆâ–€",
				"     â– â–„â–„â–€â–’â–„â–„â–„â–€â–€â–€ â–„â–’â–Œâ–€â–€ â–„â–„ â–€â–„â–‘â–„â–€â– â–€â–€â–ˆâ–ˆâ–„â–‘â–â–Œ   â–Œ",
				"      â–„â–ˆâ–ˆâ–“â–â–“â–€â–Œ   â–â–‘ â– â–“â–ˆâ–ˆâ– â–€â–€â– â– â–„â–„â–‘â–‘â–€â–€â–ˆâ–ˆâ–ˆâ–‘â–‘  â–ˆâ–„â– ",
				"    â– â–€â–“â–€   â–€â–Œ    â–€   â–€â–€â– â–ˆâ–„â–„â–€â–‘â–‘â–€ â–ˆâ–ˆâ–ˆâ– â–„â–ˆâ–ˆâ–‘ â–ˆâ–“",
			},
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			strInput := strings.Join(tc.input, "\n")
			input := convert.TokeniseANSIString(strInput)

			result := convert.FlipVertical(input)
			expected := [][]convert.ANSILineToken{}

			for _, line := range tc.expected {
				expected = append(expected, []convert.ANSILineToken{{FG: "", BG: "", T: line}})
			}

			PrintANSITestResults(strInput, expected, result, t)
			Assert(expected, result, t)
		})
	}
}
func TestVerticalMap(t *testing.T) {
	// Check that character exists in the vertical mirror map
	t.Run("check mapping is complete", func(t *testing.T) {
		var missing []unicodeChar
		var found []rune

		for _, r := range CompleteSet {
			if _, exists := convert.VerticalMirrorMap[r.char]; exists {
				found = append(found, r.char)
			} else {
				missing = append(missing, r)
			}
		}

		// for batch := range slices.Chunk(missing, 4) {
		// 	for _, ch := range batch {
		// 		fmt.Printf("U+%X '%c', ", ch.code, ch.char)
		// 	}
		// 	fmt.Println()
		// }

		completeSetStrings := []string{}
		for _, ch := range CompleteSet {
			completeSetStrings = append(completeSetStrings, fmt.Sprintf("U+%X '%c'", ch.code, ch.char))
		}
		completeMissingStrings := []string{}
		for _, ch := range missing {
			completeMissingStrings = append(completeMissingStrings, fmt.Sprintf("U+%X '%c'", ch.code, ch.char))
		}
		completeFoundStrings := []string{}
		for _, ch := range found {
			completeFoundStrings = append(completeFoundStrings, fmt.Sprintf("U+%X '%c'", ch, ch))
		}

		// PrintSimpleTestResults(
		// 	strings.Join(completeSetStrings, ", "),
		// 	"",
		// 	strings.Join(completeMissingStrings, ", "),
		// )
		// Assert(len(missing), len(CompleteSet), t)
		// Assert(len(missing), 0, t)
	})
}
